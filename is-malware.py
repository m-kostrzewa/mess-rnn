#!/usr/bin/python3
#
# Runs a single sample through the whole data collection pipeline, and then
# uses a pretrained model to determine if the sample is malicious or not.
#

from common import *
import analyze
import preprocess

log = logging.getLogger("ismalware")
config = configparser.ConfigParser()


def main():
    args = parse_args()
    init(args.config)
    zip_path = collect_data(args)
    encoding_path = preprocess_data(zip_path, args)
    bundle_path = bundle_data(encoding_path, args)
    predict(bundle_path, args)


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("--input", type=str, required=True,
                        help="Path to analyzed sample. Must be relative to "
                             "raw_base_dir in config.")
    parser.add_argument("--descriptor", type=str, default=None,
                        help="Path to sample descriptor (if needed). "
                             "Must be relative to raw_base_dir in config.")
    parser.add_argument("--config", type=str, default="mess-rnn.cfg",
                        help="Config filepath.")
    return parser.parse_args()


def init(config_path):
    config.read([config_path])
    init_logger(config)


def collect_data(args):
    log.info("------ STEP 1/4: Collecting data (analyze.py) ------")

    in_base_dir = config.get("Workspace", "raw_base_dir")
    sample = [os.path.join(in_base_dir, args.input)]
    descriptor = [os.path.join(in_base_dir, args.descriptor)] \
                 if args.descriptor is not None else []

    analyze.init(args.config)
    zips = analyze.analyze(samples_paths=sample,
                           descriptors_paths=descriptor)
    return zips[0] # we put just one sample in, so we expect only one zip out


def preprocess_data(zip_path, args):
    log.info("------ STEP 2/4: Preprocessing data (preprocess.py) ------")
    target_name = config.get("Common", "sample_target_name")
    preprocess.init(args.config)
    files = preprocess.preprocess([zip_path], target_name)
    target_enc_file = [f for f in files if TARGET_PROCESS_FILENAME in f]
    return target_enc_file


def bundle_data(target_encoding_path, args):
    log.info("------ STEP 3/4: Bundling data (bundle.py) ------")


def predict(bundle, args):
    log.info("------ STEP 4/4: Testing if sample is malicious (rnn.py) ------")


if __name__ == "__main__":
    main()
